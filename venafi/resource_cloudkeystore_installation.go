package venafi

import (
	"context"
	"fmt"

	"github.com/google/uuid"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/Venafi/vcert/v5/pkg/certificate"
	"github.com/Venafi/vcert/v5/pkg/domain"
	"github.com/Venafi/vcert/v5/pkg/endpoint"
	"github.com/Venafi/vcert/v5/pkg/venafi/cloud"
)

const (
	cloudKeystoreInstallationKeystoreID               = "keystore_id"
	cloudKeystoreInstallationCertificateID            = "certificate_id"
	cloudKeystoreInstallationCloudCertificateName     = "cloud_certificate_name"
	cloudKeystoreInstallationCloudCertificateID       = "cloud_certificate_id"
	cloudKeystoreInstallationCloudCertificateMetadata = "cloud_certificate_metadata"
)

func resourceCloudKeystoreInstallation() *schema.Resource {
	return &schema.Resource{
		CreateContext: resourceCloudKeystoreInstallationCreate,
		ReadContext:   resourceCloudKeystoreInstallationRead,
		UpdateContext: resourceCloudKeystoreInstallationDelete,
		DeleteContext: resourceCloudKeystoreInstallationUpdate,
		Importer: &schema.ResourceImporter{
			StateContext: resourceCloudKeystoreInstallationImport,
		},
		Schema: map[string]*schema.Schema{
			cloudKeystoreInstallationKeystoreID: {
				Type:        schema.TypeString,
				Description: "ID of the keystore where the certificate will be provisioned",
				Required:    true,
				ForceNew:    true,
			},
			cloudKeystoreInstallationCertificateID: {
				Type:        schema.TypeString,
				Description: "ID of the certificate to be provisioned to the keystore",
				Required:    true,
			},
			cloudKeystoreInstallationCloudCertificateName: {
				Type:        schema.TypeString,
				Description: "ID of the parent Cloud Provider the keystore belongs to",
				Required:    false,
				Optional:    true,
				Computed:    true,
				ForceNew:    true,
			},
			cloudKeystoreInstallationCloudCertificateID: {
				Type:        schema.TypeString,
				Description: "ID of the certificate after it has been provisioned to the cloud keystore",
				Computed:    true,
			},
			cloudKeystoreInstallationCloudCertificateMetadata: {
				Type:        schema.TypeMap,
				Description: "Metadata of the certificate after it has been provisioned to the cloud keystore",
				Computed:    true,
				Elem: &schema.Schema{
					Type:     schema.TypeString,
					Computed: true,
				},
			},
		},
	}
}

func resourceCloudKeystoreInstallationCreate(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	tflog.Info(ctx, "Creating cloud keystore installation")
	connector, err := getConnection(ctx, meta)
	if err != nil {
		return diag.FromErr(err)
	}

	// Check Connector is VCP
	if connector.GetType() != endpoint.ConnectorTypeCloud {
		return buildStandardDiagError(fmt.Sprintf("venafi platform detected as [%s]. Cloud Keystore Installation resource is only available for VCP", connector.GetType().String()))
	}
	cloudConnector, ok := connector.(*cloud.Connector)
	if !ok {
		return buildStandardDiagError(fmt.Sprintf("unexpected Connector type. Expected *cloud.Connector, got %T", connector))
	}

	keystoreID := d.Get(cloudKeystoreInstallationKeystoreID).(string)
	certificateID := d.Get(cloudKeystoreInstallationCertificateID).(string)
	cloudCertificateName := d.Get(cloudKeystoreInstallationCloudCertificateName).(string)

	// Check certificate is CSR service generated
	isService, err := cloudConnector.IsCSRServiceGenerated(&certificate.Request{
		CertID: certificateID,
	})
	if err != nil {
		return diag.FromErr(err)
	}
	if !isService {
		return buildStandardDiagError("Cloud Keystore Installation resource only supports certificates whose CSR was generated by VCP")
	}

	// Get parent CloudKeystore
	keystoreRequest := domain.GetCloudKeystoreRequest{
		CloudKeystoreID: &keystoreID,
	}
	cloudKeystore, err := cloudConnector.GetCloudKeystore(keystoreRequest)
	if err != nil {
		return diag.FromErr(err)
	}

	// Provision certificate to keystore
	options := getProvisioningOptions(ctx, cloudKeystore.Type, cloudCertificateName)
	request := getProvisioningRequest(keystoreID, certificateID)
	metadata, err := cloudConnector.ProvisionCertificate(request, options)
	if err != nil {
		return diag.FromErr(err)
	}

	// Get newly created machine identity
	machineIdentity, err := getMachineIdentity(ctx, metadata.MachineIdentityID, meta)
	if err != nil {
		return diag.FromErr(err)
	}

	// Store machine identity in state
	err = storeMachineIdentityInState(ctx, machineIdentity, d)
	if err != nil {
		return diag.FromErr(err)
	}

	return diag.Diagnostics{}
}

func resourceCloudKeystoreInstallationRead(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	tflog.Info(ctx, "Reading cloud keystore installation")

	// Get machine identity from VCP
	id := d.Id()
	machineIdentity, err := getMachineIdentity(ctx, id, meta)
	if err != nil {
		return diag.FromErr(err)
	}

	// Store machine identity in state
	err = storeMachineIdentityInState(ctx, machineIdentity, d)
	if err != nil {
		return diag.FromErr(err)
	}

	return diag.Diagnostics{}
}

func resourceCloudKeystoreInstallationUpdate(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	tflog.Info(ctx, "Updating cloud keystore installation")

	connector, err := getConnection(ctx, meta)
	if err != nil {
		return diag.FromErr(err)
	}

	// Check Connector is VCP
	if connector.GetType() != endpoint.ConnectorTypeCloud {
		return buildStandardDiagError(fmt.Sprintf("venafi platform detected as [%s]. Cloud Keystore Installation resource is only available for VCP", connector.GetType().String()))
	}
	cloudConnector, ok := connector.(*cloud.Connector)
	if !ok {
		return buildStandardDiagError(fmt.Sprintf("venafi platform detected as [%s]. Cloud Keystore Installation resource is only available for VCP", connector.GetType().String()))
	}

	machineIdentityID := d.Id()
	certificateID := d.Get(cloudKeystoreInstallationCertificateID).(string)

	// Check certificate is CSR service generated
	isService, err := cloudConnector.IsCSRServiceGenerated(&certificate.Request{
		CertID: certificateID,
	})
	if err != nil {
		return diag.FromErr(err)
	}
	if !isService {
		return buildStandardDiagError("Cloud Keystore Installation resource only supports certificates whose CSR was generated by VCP")
	}

	request := domain.ProvisioningRequest{
		MachineIdentityID: &machineIdentityID,
		CertificateID:     &certificateID,
	}
	metadata, err := cloudConnector.ProvisionCertificateToMachineIdentity(request)
	if err != nil {
		return diag.FromErr(err)
	}

	// Get newly created machine identity
	machineIdentity, err := getMachineIdentity(ctx, metadata.MachineIdentityID, meta)
	if err != nil {
		return diag.FromErr(err)
	}

	// Store machine identity in state
	err = storeMachineIdentityInState(ctx, machineIdentity, d)
	if err != nil {
		return diag.FromErr(err)
	}

	return diag.Diagnostics{}
}

func resourceCloudKeystoreInstallationDelete(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	tflog.Info(ctx, "Deleting cloud keystore installation")

	connector, err := getConnection(ctx, meta)
	if err != nil {
		return diag.FromErr(err)
	}

	// Check Connector is VCP
	if connector.GetType() != endpoint.ConnectorTypeCloud {
		return buildStandardDiagError(fmt.Sprintf("venafi platform detected as [%s]. Cloud Keystore Installation resource is only available for VCP", connector.GetType().String()))
	}
	cloudConnector, ok := connector.(*cloud.Connector)
	if !ok {
		return buildStandardDiagError(fmt.Sprintf("venafi platform detected as [%s]. Cloud Keystore Installation resource is only available for VCP", connector.GetType().String()))
	}

	// Delete machine identity
	machineIdentityID := d.Id()
	id, err := uuid.Parse(machineIdentityID)
	if err != nil {
		return diag.FromErr(err)
	}
	deleted, err := cloudConnector.DeleteMachineIdentity(id)
	if err != nil {
		return diag.FromErr(err)
	}
	if !deleted {
		return buildStandardDiagError("failed to delete Cloud Keystore installation")
	}

	// Remove id from state
	d.SetId("")
	return diag.Diagnostics{}
}

func resourceCloudKeystoreInstallationImport(ctx context.Context, d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	tflog.Info(ctx, "Importing cloud keystore installation")
	id := d.Id()
	if id == "" {
		return nil, fmt.Errorf("cloud keystore installation ID is empty")
	}

	// Get machine identity from VCP
	machineIdentity, err := getMachineIdentity(ctx, id, meta)
	if err != nil {
		return nil, err
	}

	// Store machine identity in state
	err = storeMachineIdentityInState(ctx, machineIdentity, d)
	if err != nil {
		return nil, err
	}

	return []*schema.ResourceData{d}, nil
}

func getProvisioningOptions(ctx context.Context, cloudKeystoreType domain.CloudKeystoreType, certificateName string) *domain.ProvisioningOptions {
	if cloudKeystoreType == domain.CloudKeystoreTypeACM {
		tflog.Info(ctx, fmt.Sprintf("cloud keystore type %s does not support provisioning options. Ignoring certificate name value: %s", cloudKeystoreType, certificateName))
		return nil
	}

	tflog.Info(ctx, "using provisioning options", map[string]interface{}{
		"name": certificateName,
	})
	return &domain.ProvisioningOptions{
		CloudCertificateName: certificateName,
	}
}

func getProvisioningRequest(keystoreID string, certificateID string) *domain.ProvisioningRequest {
	return &domain.ProvisioningRequest{
		CertificateID: &certificateID,
		KeystoreID:    &keystoreID,
	}
}

func getMachineIdentity(ctx context.Context, machineIdentityID string, meta interface{}) (*domain.CloudMachineIdentity, error) {
	tflog.Info(ctx, "Retrieving machine identity from VCP")
	connector, err := getConnection(ctx, meta)
	if err != nil {
		return nil, err
	}

	// Check Connector is VCP
	if connector.GetType() != endpoint.ConnectorTypeCloud {
		return nil, fmt.Errorf("venafi platform detected as [%s]. Cloud Keystore Installation resource is only available for VCP", connector.GetType().String())
	}
	cloudConnector, ok := connector.(*cloud.Connector)
	if !ok {
		return nil, fmt.Errorf("venafi platform detected as [%s]. Cloud Keystore Installation resource is only available for VCP", connector.GetType().String())
	}

	// Get machine identity value from VCP
	request := domain.GetCloudMachineIdentityRequest{
		MachineIdentityID: &machineIdentityID,
	}
	machineIdentity, err := cloudConnector.GetMachineIdentity(request)
	if err != nil {
		return nil, err
	}

	return machineIdentity, nil
}

func storeMachineIdentityInState(ctx context.Context, machineIdentity *domain.CloudMachineIdentity, d *schema.ResourceData) error {
	tflog.Info(ctx, "Storing machine identity in terraform state")

	if machineIdentity == nil {
		return fmt.Errorf("cannot store machine identity. CloudMachineIdenity object is nil")
	}
	if d == nil {
		return fmt.Errorf("cannot store machine identity. ResourceData object is nil")
	}

	// Store values in state
	err := d.Set(cloudKeystoreInstallationKeystoreID, machineIdentity.CloudKeystoreID)
	if err != nil {
		return err
	}
	err = d.Set(cloudKeystoreInstallationCertificateID, machineIdentity.CertificateID)
	if err != nil {
		return err
	}
	cloudCertificateName, err := getCloudCertNameFromMachineIdentity(machineIdentity.Metadata)
	if err != nil {
		return err
	}
	if cloudCertificateName != "" {
		err = d.Set(cloudKeystoreInstallationCloudCertificateName, cloudCertificateName)
		if err != nil {
			return err
		}
	}
	cloudID, err := getCloudIDFromMachineIdentity(machineIdentity.Metadata)
	if err != nil {
		return err
	}
	err = d.Set(cloudKeystoreInstallationCloudCertificateID, cloudID)
	if err != nil {
		return err
	}
	metadataMap, err := getMetadataMapFromMachineIdentity(machineIdentity.Metadata)
	if err != nil {
		return err
	}
	err = d.Set(cloudKeystoreInstallationCloudCertificateMetadata, metadataMap)
	if err != nil {
		return err
	}

	d.SetId(machineIdentity.ID.String())

	return nil
}

func getCloudCertNameFromMachineIdentity(metadata *domain.CertificateCloudMetadata) (string, error) {
	keystoreType := metadata.GetKeystoreType()
	if keystoreType == domain.CloudKeystoreTypeAKV || keystoreType == domain.CloudKeystoreTypeGCM {
		name, err := getAttributeFromMachineIdentity(metadata, "name")
		if err != nil {
			return "", err
		}
		return name, nil
	}
	return "", nil
}

func getCloudIDFromMachineIdentity(metadata *domain.CertificateCloudMetadata) (string, error) {
	keystoreType := metadata.GetKeystoreType()
	switch keystoreType {
	case domain.CloudKeystoreTypeACM:
		return getCloudIDFromMachineIdentityACM(metadata)
	case domain.CloudKeystoreTypeAKV:
		return getCloudIDFromMachineIdentityAKV(metadata)
	case domain.CloudKeystoreTypeGCM:
		return getCloudIDFromMachineIdentityGCM(metadata)
	default:
		return "", fmt.Errorf("unexpected cloud metadata type: %s", keystoreType)
	}
}

func getMetadataMapFromMachineIdentity(metadata *domain.CertificateCloudMetadata) (map[string]string, error) {
	metadataMap := make(map[string]string)
	if metadata == nil {
		return nil, fmt.Errorf("cloud metadata is nil")
	}
	if metadata.GetKeystoreType() == domain.CloudKeystoreTypeACM {
		return getMetadataMapFromMachineIdentityACM(metadata)
	}
	if metadata.GetKeystoreType() == domain.CloudKeystoreTypeAKV {
		return getMetadataMapFromMachineIdentityAKV(metadata)
	}
	if metadata.GetKeystoreType() == domain.CloudKeystoreTypeGCM {
		return getMetadataMapFromMachineIdentityGCM(metadata)
	}

	return metadataMap, nil
}

func getCloudIDFromMachineIdentityACM(metadata *domain.CertificateCloudMetadata) (string, error) {
	return getAttributeFromMachineIdentity(metadata, "arn")
}

func getCloudIDFromMachineIdentityAKV(metadata *domain.CertificateCloudMetadata) (string, error) {
	return getAttributeFromMachineIdentity(metadata, "azureId")
}

func getCloudIDFromMachineIdentityGCM(metadata *domain.CertificateCloudMetadata) (string, error) {
	return getAttributeFromMachineIdentity(metadata, "gcpId")
}

func getAttributeFromMachineIdentity(metadata *domain.CertificateCloudMetadata, attribute string) (string, error) {
	if metadata == nil {
		return "", fmt.Errorf("cloud metadata is nil")
	}
	val := metadata.GetValue(attribute)
	if val == nil {
		return "", fmt.Errorf("%s not found in metadata", attribute)
	}
	if _, ok := val.(string); !ok {
		return "", fmt.Errorf("unexpected type for %s. Expected string, got %T", attribute, val)
	}

	return val.(string), nil
}

func getMetadataMapFromMachineIdentityACM(metadata *domain.CertificateCloudMetadata) (map[string]string, error) {
	metadataMap := make(map[string]string)

	arn, err := getCloudIDFromMachineIdentityACM(metadata)
	if err != nil {
		return nil, err
	}

	metadataMap["type"] = domain.CloudKeystoreTypeACM.String()
	metadataMap["arn"] = arn

	return metadataMap, nil
}

func getMetadataMapFromMachineIdentityAKV(metadata *domain.CertificateCloudMetadata) (map[string]string, error) {
	metadataMap := make(map[string]string)

	id, err := getCloudIDFromMachineIdentityAKV(metadata)
	if err != nil {
		return nil, err
	}
	name, err := getAttributeFromMachineIdentity(metadata, "name")
	if err != nil {
		return nil, err
	}
	version, err := getAttributeFromMachineIdentity(metadata, "version")
	if err != nil {
		return nil, err
	}

	metadataMap["type"] = domain.CloudKeystoreTypeAKV.String()
	metadataMap["id"] = id
	metadataMap["name"] = name
	metadataMap["version"] = version

	return metadataMap, nil
}

func getMetadataMapFromMachineIdentityGCM(metadata *domain.CertificateCloudMetadata) (map[string]string, error) {
	metadataMap := make(map[string]string)

	id, err := getCloudIDFromMachineIdentityGCM(metadata)
	if err != nil {
		return nil, err
	}
	name, err := getAttributeFromMachineIdentity(metadata, "name")
	if err != nil {
		return nil, err
	}

	metadataMap["type"] = domain.CloudKeystoreTypeGCM.String()
	metadataMap["id"] = id
	metadataMap["name"] = name

	return metadataMap, nil
}
